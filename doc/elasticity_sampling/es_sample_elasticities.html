<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of es_sample_elasticities</title>
  <meta name="keywords" content="es_sample_elasticities">
  <meta name="description" content="ES_SAMPLE_ELASTICITIES - Elasticity phase">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="#">elasticity_sampling</a> &gt; es_sample_elasticities.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for ./elasticity_sampling&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>es_sample_elasticities
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>ES_SAMPLE_ELASTICITIES - Elasticity phase</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function result = es_sample_elasticities(N, W, ind_ext, es_constraints, es_options, c0, c, u, J, Keq, mu, K, Kma, zeta, A) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ES_SAMPLE_ELASTICITIES - Elasticity phase

 result = es_sample_elasticities(N, W, ind_ext, es_constraints, es_options, c0, c, u, J, Keq, mu, K, Kma, zeta, A)

 Elasticity sampling: run elasticity sampling phase and MCA phase 


 Inputs (= Outputs of es_sample_steady_state; with nm: # metabolites; nr: # reactions)

   N         - Stoichiometric matrix (nm x nr)
   W         - Allosteric regulation matrix (nr x nm)
   ind_ext   - indices of external metabolites
   c0        - Vector of chemical equilibrium concentrations (optional)
   c         - Vector of concentrations
   u         - Vector of enzyme levels
   J         - Flux vector
   Keq       - Vector of equilibrium constants
   mu        - Vector of chemical potentials
   K         - Kernel matrix 
   Kma       - Vector of mass-action ratios
   zeta      - zeta vector computed from reaction affinities
   A         - Vector of reaction affinities (thermodynamic driving forces)

 For the inputs 'es_constraints' and 'es_options', see 'es_default_options'

 Fields in 'es_constraints' and 'es_options' relevant to this function:

   es_constraints.beta_M_fix     - predefined beta values (only used if non-zero)
   es_constraints.beta_A_fix     - predefined beta values (only used if non-zero)
   es_constraints.beta_I_fix     - predefined beta values (only used if non-zero)
   es_options.kinetic_law        - Rate law {'cs','ms', ...}
   es_options.h                  - vector of Hill exponents (one for each reaction)
   es_options.no_equilibrium     - For inactive reactions: assume no equilibrium (Boolean)
   es_options.KV_prior_mean      - .. and KV value to be used in this case
   es_options.flag_test          - Run tests? (Boolean)
   es_options.flag_second_order  - Compute second-order elasticities? (Boolean)
   es_options.zv                 - Flux weights for 2nd order resp. coeff output function
   es_options.zc                 - Conc. weights for 2nd order resp. coeff output function

 All output data are stored in a structure 'result' with fields:
   result.c            - Metabolite levels      
   result.c0           - Equilibrium metabolite levels      
   result.u            - Enzyme levels
   result.A            - Reaction affinities
   result.zeta         - zeta vector (computed from reaction affinities)
   result.mu           - Chemical potentials
   result.J            - Fluxes
   result.v            - Reaction rates (computed from rate laws, v=J)
   result.v_plus       - Microscopic forward rates
   result.v_minus      - Microscopic reverse rates
   result.Keq          - Equilibrium constants
   result.Kma          - Mass-action ratios
   result.KA           - Activation constants
   result.KI           - Inhibition constants
   result.KM           - Reactant constants
   result.KV           - Velocity constants (geometric mean of catalytic constants)
   result.Kplus        - Forward catalytic constants
   result.Kminus       - Reverse catalytic constants
   result.saturation   - Saturation values
   result.elasticities - Elasticities (scaled and unscaled)
   result.control      - Control and response coefficients (scaled and unscaled)
   result.K            - Kernel matrix 
   result.kinetics     - kinetic rate laws (to be inserted into 'network')

 See also: <a href="es_sample_model.html" class="code" title="function [result, es_options, es_constraints] = es_sample_model(N, W, ind_ext, es_constraints, es_options)">es_sample_model</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href=".././elasticity_sampling/es_functions/es_control_analysis.html" class="code" title="function control = es_control_analysis(RSp, RJp, RSpp, RJpp, c, v, u, ind_ext)">es_control_analysis</a>	ES_CONTROL_ANALYSIS - Compute various control and response coefficients</li><li><a href=".././elasticity_sampling/es_functions/sample_saturation_parameters.html" class="code" title="function [alpha_A,alpha_I,alpha_M] = sample_saturation_parameters(N,W,ind_ext,es_options,es_constraints)">sample_saturation_parameters</a>	[alpha_A,alpha_I,alpha_M] = sample_saturation_parameters(N,W,ind_ext,es_options)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href=".././elasticity_sampling/es_functions/es_sample_model_read_flux_task.html" class="code" title="function [result, es_options, es_constraints] = es_sample_model_naama_read(N,W,ind_ext,es_constraints,es_options,filename)">es_sample_model_read_flux_task</a>	result = es_sample_model_naama_read(N, W, ind_ext, es_constraints, es_options, filename)</li><li><a href="es_sample_model.html" class="code" title="function [result, es_options, es_constraints] = es_sample_model(N, W, ind_ext, es_constraints, es_options)">es_sample_model</a>	ES_SAMPLE_MODEL - Sample all model parameters for a network</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function result = es_sample_elasticities(N, W, ind_ext, es_constraints, es_options, c0, c, u, J, Keq, mu, K, Kma, zeta, A)</a>
0002 
0003 <span class="comment">% ES_SAMPLE_ELASTICITIES - Elasticity phase</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% result = es_sample_elasticities(N, W, ind_ext, es_constraints, es_options, c0, c, u, J, Keq, mu, K, Kma, zeta, A)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Elasticity sampling: run elasticity sampling phase and MCA phase</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Inputs (= Outputs of es_sample_steady_state; with nm: # metabolites; nr: # reactions)</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%   N         - Stoichiometric matrix (nm x nr)</span>
0013 <span class="comment">%   W         - Allosteric regulation matrix (nr x nm)</span>
0014 <span class="comment">%   ind_ext   - indices of external metabolites</span>
0015 <span class="comment">%   c0        - Vector of chemical equilibrium concentrations (optional)</span>
0016 <span class="comment">%   c         - Vector of concentrations</span>
0017 <span class="comment">%   u         - Vector of enzyme levels</span>
0018 <span class="comment">%   J         - Flux vector</span>
0019 <span class="comment">%   Keq       - Vector of equilibrium constants</span>
0020 <span class="comment">%   mu        - Vector of chemical potentials</span>
0021 <span class="comment">%   K         - Kernel matrix</span>
0022 <span class="comment">%   Kma       - Vector of mass-action ratios</span>
0023 <span class="comment">%   zeta      - zeta vector computed from reaction affinities</span>
0024 <span class="comment">%   A         - Vector of reaction affinities (thermodynamic driving forces)</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% For the inputs 'es_constraints' and 'es_options', see 'es_default_options'</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% Fields in 'es_constraints' and 'es_options' relevant to this function:</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%   es_constraints.beta_M_fix     - predefined beta values (only used if non-zero)</span>
0031 <span class="comment">%   es_constraints.beta_A_fix     - predefined beta values (only used if non-zero)</span>
0032 <span class="comment">%   es_constraints.beta_I_fix     - predefined beta values (only used if non-zero)</span>
0033 <span class="comment">%   es_options.kinetic_law        - Rate law {'cs','ms', ...}</span>
0034 <span class="comment">%   es_options.h                  - vector of Hill exponents (one for each reaction)</span>
0035 <span class="comment">%   es_options.no_equilibrium     - For inactive reactions: assume no equilibrium (Boolean)</span>
0036 <span class="comment">%   es_options.KV_prior_mean      - .. and KV value to be used in this case</span>
0037 <span class="comment">%   es_options.flag_test          - Run tests? (Boolean)</span>
0038 <span class="comment">%   es_options.flag_second_order  - Compute second-order elasticities? (Boolean)</span>
0039 <span class="comment">%   es_options.zv                 - Flux weights for 2nd order resp. coeff output function</span>
0040 <span class="comment">%   es_options.zc                 - Conc. weights for 2nd order resp. coeff output function</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% All output data are stored in a structure 'result' with fields:</span>
0043 <span class="comment">%   result.c            - Metabolite levels</span>
0044 <span class="comment">%   result.c0           - Equilibrium metabolite levels</span>
0045 <span class="comment">%   result.u            - Enzyme levels</span>
0046 <span class="comment">%   result.A            - Reaction affinities</span>
0047 <span class="comment">%   result.zeta         - zeta vector (computed from reaction affinities)</span>
0048 <span class="comment">%   result.mu           - Chemical potentials</span>
0049 <span class="comment">%   result.J            - Fluxes</span>
0050 <span class="comment">%   result.v            - Reaction rates (computed from rate laws, v=J)</span>
0051 <span class="comment">%   result.v_plus       - Microscopic forward rates</span>
0052 <span class="comment">%   result.v_minus      - Microscopic reverse rates</span>
0053 <span class="comment">%   result.Keq          - Equilibrium constants</span>
0054 <span class="comment">%   result.Kma          - Mass-action ratios</span>
0055 <span class="comment">%   result.KA           - Activation constants</span>
0056 <span class="comment">%   result.KI           - Inhibition constants</span>
0057 <span class="comment">%   result.KM           - Reactant constants</span>
0058 <span class="comment">%   result.KV           - Velocity constants (geometric mean of catalytic constants)</span>
0059 <span class="comment">%   result.Kplus        - Forward catalytic constants</span>
0060 <span class="comment">%   result.Kminus       - Reverse catalytic constants</span>
0061 <span class="comment">%   result.saturation   - Saturation values</span>
0062 <span class="comment">%   result.elasticities - Elasticities (scaled and unscaled)</span>
0063 <span class="comment">%   result.control      - Control and response coefficients (scaled and unscaled)</span>
0064 <span class="comment">%   result.K            - Kernel matrix</span>
0065 <span class="comment">%   result.kinetics     - kinetic rate laws (to be inserted into 'network')</span>
0066 <span class="comment">%</span>
0067 <span class="comment">% See also: es_sample_model</span>
0068 
0069 
0070 <span class="comment">% ----------------------------------------------------------------</span>
0071 <span class="comment">% sample alpha, values and compute beta and gamma values</span>
0072 
0073 [nm,nr] = size(N);
0074 
0075 [alpha_A, alpha_I, alpha_M] = <a href=".././elasticity_sampling/es_functions/sample_saturation_parameters.html" class="code" title="function [alpha_A,alpha_I,alpha_M] = sample_saturation_parameters(N,W,ind_ext,es_options,es_constraints)">sample_saturation_parameters</a>(N,W,ind_ext,es_options,es_constraints);
0076 
0077 [beta_A,gamma_A] = alpha_to_betagamma(alpha_A);
0078 [beta_I,gamma_I] = alpha_to_betagamma(alpha_I);
0079 [beta_M,gamma_M] = alpha_to_betagamma(alpha_M);
0080 KA               = alpha_to_k(alpha_A,c);
0081 KI               = alpha_to_k(alpha_I,c);
0082 KM               = alpha_to_k(alpha_M,c);
0083 
0084 
0085 <span class="comment">% ----------------------------------------------------------------</span>
0086 <span class="comment">% compute remaining model parameters (KV, Kplus, Kminus)</span>
0087 
0088 <span class="comment">% compute KV (given sampled u and comparison between J and preliminary v</span>
0089 
0090 KM_full     = full(KM); KM_full(KM_full==0) = 1;
0091 this_KV     = ones(nr,1);
0092 v_pre       = modular_velocities(es_options.kinetic_law,N,W,ind_ext,u,c,KA,KI,KM,this_KV,Keq,es_options.h);
0093 ind_off     = find([v_pre==0].*[A~=0]);
0094 ind_off_A   = find([v_pre==0].*[A==0]);
0095 
0096 <span class="comment">%-----------------------------</span>
0097 <span class="comment">% FIX, TO BE REMOVED LATER:</span>
0098 es_options = join_struct(struct(<span class="string">'no_equilibrium'</span>,1),es_options);
0099 <span class="comment">%-----------------------------</span>
0100 
0101 
0102 <span class="keyword">if</span> es_options.no_equilibrium,
0103   <span class="keyword">if</span> length(ind_off),  display(<span class="string">'Vanishing rates: setting enzyme values = 0'</span>); <span class="keyword">end</span>
0104   u(ind_off)     = 0;
0105   v_pre(ind_off) = 1;
0106   KV          = J./v_pre;
0107   KV(ind_off) = es_options.KV_prior_mean;
0108 <span class="keyword">else</span>,
0109   <span class="keyword">if</span> length(ind_off),  display(<span class="string">'Vanishing rates: setting KV values = 0'</span>); <span class="keyword">end</span>
0110   v_pre(ind_off) = 1;
0111   KV          = J./v_pre;
0112   KV(ind_off) = 0;
0113 <span class="keyword">end</span>
0114 
0115 <span class="comment">% arbitrary choice (since nothing is known...)</span>
0116 
0117 u(ind_off_A)  = nanmedian(u);
0118 KV(ind_off_A) = nanmedian(KV);
0119 KV(isnan(KV)) = nanmedian(KV);
0120 
0121 <span class="keyword">if</span> sum(KV&lt;0), error(<span class="string">'Problem with flux directions'</span>); <span class="keyword">end</span>
0122 
0123 <span class="comment">% compute reaction velocities</span>
0124 [v, v_plus, v_minus] = modular_velocities(es_options.kinetic_law,N,W,ind_ext,u,c,KA,KI,KM,KV,Keq,es_options.h);
0125 [Kplus,Kminus]       = ms_compute_Kcat(N,KM,KV,Keq);
0126 
0127 <span class="comment">% ----------------------------------------------------------------</span>
0128 <span class="comment">% Tests</span>
0129 
0130 <span class="keyword">if</span> es_options.flag_test,
0131   [Mplus, Mminus, Wplus, Wminus, nm, nr, N_int] = make_structure_matrices(N,W,ind_ext,es_options.h);
0132   dc_td             = N_int * J 
0133   <span class="keyword">if</span> length(c0),
0134     def_keq_mismatch  = [log(Keq) - N' * log(c0)]
0135     v_eq = modular_velocities(es_options.kinetic_law,N,W,ind_ext,u,c0,KA,KI,KM,KV,Keq,es_options.h)
0136     max(abs( def_keq_mismatch)) 
0137   max(abs( v_eq  )) 
0138   <span class="keyword">end</span>
0139   sign_J_A_mismatch = [sign(J) - sign(A)];
0140   max(abs( dc_td)) 
0141   max(abs( sign_J_A_mismatch )) 
0142 <span class="keyword">end</span>
0143 
0144 
0145 <span class="comment">% ----------------------------------------------------------------</span>
0146 <span class="comment">% Compute elasticities:</span>
0147 <span class="comment">%  o scaled elasticities (single reaction directions) only require alpha values</span>
0148 <span class="comment">%  o unscaled and total elasticities also require velocities and concentrations</span>
0149 
0150 v_plus_fallback  = ones(size(v));
0151 v_minus_fallback = ones(size(v));
0152 
0153 E = compute_modular_elasticities(es_options.kinetic_law, N, W, ind_ext, alpha_A, alpha_I, alpha_M, v, A, u, c, es_options.h, v_plus_fallback, v_minus_fallback, es_options.flag_second_order);
0154 
0155 <span class="comment">% -------------------------------------------------------------</span>
0156 <span class="comment">% Compute unscaled and scaled response coefficients</span>
0157 
0158 Ec   = E.un_E_c;
0159 Eu   = E.un_E_u;
0160 Es   = E.un_E_c(:,ind_ext);
0161 Ep   = [Eu Es];
0162 
0163 external  = zeros(nm,1); external(ind_ext) = 1;
0164 
0165 <span class="keyword">if</span> prod(size(N)) &gt; 10^4, <span class="comment">% compute approximation of NR_int and L_int</span>
0166   epsilon_nullspace = 10^-20;
0167   N_int = N(find(external==0),:);
0168   <span class="comment">%%[U,S,V]  = svds(sparse(N_int),100);</span>
0169   [U,S,V]  = svd(full(N_int));
0170   ii =  find(abs(diag(S))&gt;epsilon_nullspace); 
0171   L_int  = U(:,ii) * S(ii,ii);
0172   NR_int = V(:,ii)';
0173   [CJ, CS, L_int, NR_int, M, M_adj] = control_coefficients(N, Ec, external, [], NR_int, L_int);
0174 <span class="keyword">else</span>,
0175   [CJ, CS, L_int, NR_int, M, M_adj] = control_coefficients(N, Ec, external);
0176 <span class="keyword">end</span>
0177 
0178 
0179 <span class="comment">% -------------------------------------------------------------</span>
0180 <span class="comment">% second order</span>
0181 
0182 <span class="keyword">if</span> es_options.flag_second_order * [length(es_options.zc) + length(es_options.zv) == 0],
0183 
0184    <span class="comment">%% compute full second-order response matrices</span>
0185    
0186    Ecc  = E.un_E_cc;
0187    Ecu  = E.un_E_cu;
0188    Euu  = E.un_E_uu;
0189    Ecs  = E.un_E_cc(:,:,ind_ext);
0190    Ess  = E.un_E_cc(:,ind_ext,ind_ext);
0191    Esu  = E.un_E_cu(:,ind_ext,:);
0192   
0193    np  = size(Ep,2);
0194    Ecp = sptensor([nr,nm,np]);
0195    Epp = sptensor([nr,np,np]);
0196    Ecp(1:nr,1:nm,1:nr)       = Ecu;
0197    Ecp(1:nr,1:nm,nr+1:np)    = Ecs;
0198    Epp(1:nr,1:nr,1:nr)       = Euu;
0199    Epp(1:nr,1:nr,nr+1:np)    = permute(Esu,[1 3 2]);
0200    Epp(1:nr,nr+1:np,1:nr)    = Esu;
0201    Epp(1:nr,nr+1:np,nr+1:np) = Ess;
0202    
0203    [RSp,RJp,RSpp,RJpp] = response_coefficients_sparse(CS,Ec,Ep,Ecc,Ecp,Epp);
0204 
0205    <span class="comment">%% &quot;response&quot; effect of external metabolite to itself</span>
0206    RSp(ind_ext,nr+1:np) = eye(length(ind_ext));
0207    control              = <a href=".././elasticity_sampling/es_functions/es_control_analysis.html" class="code" title="function control = es_control_analysis(RSp, RJp, RSpp, RJpp, c, v, u, ind_ext)">es_control_analysis</a>(RSp, RJp, RSpp, RJpp, c, v, u, ind_ext);
0208 <span class="keyword">else</span>
0209   
0210   [RSp_un,RJp_un] = response_coefficients(CS,Ec,Ep);
0211   <span class="comment">%% &quot;response&quot; effect of external metabolite to itself</span>
0212   np  = size(Ep,2);
0213   RSp_un(ind_ext,nr+1:np) = eye(length(ind_ext));
0214 
0215   control.CS  = CS;
0216   control.CJ  = CJ;
0217   control.RSp = RSp_un;
0218   control.RJp = RJp_un;
0219   control.CS_sc  = diag(1./(c)) * control.CS  * diag(v);
0220   control.CJ_sc  = diag(1./(v)) * control.CJ  * diag(v);
0221   n_ext = length(ind_ext);
0222   control.RSu_un = control.RSp(:,1:nr);
0223   control.RJu_un = control.RJp(:,1:nr);
0224   control.RSu_sc = diag(1./(c)) * control.RSp(:,1:nr) * diag(u);
0225   control.RJu_sc = diag(1./(v)) * control.RJp(:,1:nr) * diag(u);
0226   control.RSs_sc = diag(1./(c)) * control.RSp(:,end-n_ext+1:end) * diag(c(ind_ext));
0227   control.RJs_sc = diag(1./(v)) * control.RJp(:,end-n_ext+1:end) * diag(c(ind_ext));
0228   control.RSs_un = control.RSp(:,end-n_ext+1:end);
0229   control.RJs_un = control.RJp(:,end-n_ext+1:end);
0230 
0231   <span class="comment">%% Second order effects on specified target reaction</span>
0232   <span class="keyword">if</span> [length(es_options.zc) + length(es_options.zv)],    
0233     [control.Rtarget_sc_u, control.Rtarget_sc_uu] = compute_modular_response_second(<span class="keyword">...</span>
0234         es_options.zc, es_options.zv, es_options.kinetic_law,N, W, <span class="keyword">...</span>
0235         ind_ext, alpha_A, alpha_I, alpha_M, v, A, u, c, es_options.h, <span class="keyword">...</span>
0236         v_plus_fallback, v_minus_fallback,CS,CJ);
0237   <span class="keyword">end</span>
0238   
0239 <span class="keyword">end</span>
0240   
0241 <span class="comment">%% fix response coefficient of external concentration w.r.t. itself</span>
0242 <span class="keyword">for</span> ittt = 1:length(ind_ext),
0243   control.RSs_sc(ind_ext(ittt),ittt) = 1; 
0244 <span class="keyword">end</span>
0245 
0246 <span class="keyword">if</span> length(es_options.zc),
0247   [control.Rtarget_sc_u, control.Rtarget_sc_uu] = compute_modular_response_second(es_options.zc,es_options.zv,es_options.kinetic_law,N, W, ind_ext, alpha_A, alpha_I, alpha_M, v, A, u, c, es_options.h, v_plus_fallback, v_minus_fallback,CS,CJ);
0248 <span class="keyword">end</span>
0249 
0250 control.M     = M;
0251 control.M_adj = M_adj;
0252 
0253 eigmax = max(real(eig(M)));
0254 
0255 control.stable = [eigmax &lt;= 0];
0256 
0257 <span class="keyword">if</span> control.stable,
0258   display(<span class="string">'The metabolic state is stable.'</span>);
0259 <span class="keyword">else</span>
0260   display(<span class="string">'WARNING: The metabolic state is unstable.'</span>);
0261 <span class="keyword">end</span>
0262 
0263 <span class="comment">% -------------------------------------------------------------</span>
0264 <span class="comment">% write all results to data structure 'result'</span>
0265 
0266 result.c                  = c;
0267 result.c0                 = c0;
0268 result.u                  = u;
0269 result.A                  = A;
0270 result.zeta               = zeta;
0271 result.mu                 = mu;
0272 result.J                  = J; <span class="comment">% for double checking between J and v</span>
0273 result.v                  = v;
0274 result.v_plus             = v_plus;
0275 result.v_minus            = v_minus;
0276 result.Keq                = Keq;
0277 result.Kma                = Kma;
0278 result.KA                 = KA;
0279 result.KI                 = KI;
0280 result.KM                 = KM;
0281 result.KV                 = KV;
0282 result.Kplus              = Kplus;
0283 result.Kminus             = Kminus;
0284 result.saturation.alpha_A = alpha_A;
0285 result.saturation.alpha_I = alpha_I;
0286 result.saturation.alpha_M = alpha_M;
0287 result.saturation.beta_A  = beta_A;
0288 result.saturation.beta_I  = beta_I;
0289 result.saturation.beta_M  = beta_M;
0290 result.saturation.gamma_A = gamma_A;
0291 result.saturation.gamma_I = gamma_I;
0292 result.saturation.gamma_M = gamma_M;
0293 result.elasticities       = E;
0294 result.control            = control;
0295 result.control.CS         = CS;
0296 result.control.CJ         = CJ;
0297 result.K                  = K;
0298 
0299 
0300 <span class="comment">% -------------------------------------------------------------</span>
0301 <span class="comment">% kinetic parameters ready to use</span>
0302 
0303 result.kinetics.type = es_options.kinetic_law;     
0304 result.kinetics.u    = result.u;     
0305 result.kinetics.c    = result.c;     
0306 result.kinetics.KA   = result.KA;    
0307 result.kinetics.KI   = result.KI;    
0308 result.kinetics.KM   = result.KM;    
0309 result.kinetics.KV   = result.KV;    
0310 result.kinetics.Keq  = result.Keq;
0311 result.kinetics.h    = es_options.h;
0312 
0313 
0314 <span class="comment">% ----------------------------------------------------------------</span>
0315 <span class="comment">% test: do the first elasticities coincide with numerically computed elasticities?</span>
0316 
0317 <span class="keyword">if</span> 0,
0318   network          = network_construct(N,ones(size(v)),ind_ext);
0319   network.kinetics = result.kinetics;
0320   Ec               = elasticities(network,result.c);
0321   
0322   <span class="keyword">if</span> [norm(full(Ec)) - norm(full(E.un_E_c))] / norm(full(Ec)) &gt; 10^-3,
0323     warning(<span class="string">'Error in elasticities'</span>);
0324     [norm(full(Ec)) - norm(full(E.un_E_c))]
0325   <span class="keyword">end</span>
0326 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 09-Nov-2014 11:05:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>