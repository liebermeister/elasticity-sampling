<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of es_sample_steady_state</title>
  <meta name="keywords" content="es_sample_steady_state">
  <meta name="description" content="ES_SAMPLE_STEADY_STATE - Sample feasible stationary state for a network">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">elasticity_sampling</a> &gt; es_sample_steady_state.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for elasticity_sampling&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>es_sample_steady_state
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>ES_SAMPLE_STEADY_STATE - Sample feasible stationary state for a network</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [c0, c, u, v, Keq, mu, K, Kma, zeta, A] = es_sample_steady_state_state(N, W, ind_ext, es_constraints, es_options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ES_SAMPLE_STEADY_STATE - Sample feasible stationary state for a network

 [c0, c, u, v, Keq, mu, K, Kma, zeta, A] = es_sample_steady_state_state(N, W, ind_ext, es_constraints, es_options)

 Sample thermodynamically consistent steady states, including concentrations,
 fluxes, and thermodynamic quantities. Enzyme levels are freely sampled.


 Inputs (with nm: # metabolites; nr: # reactions)
   N         - Stoichiometric matrix (nm x nr)
   W         - Allosteric regulation matrix (nr x nm)
   ind_ext   - indices of external metabolites

   For the inputs 'es_constraints' and 'es_options', see 'es_default_options'

  Fields in 'es_constraints' and 'es_options' relevant to this function:
    es_options.seed               - Random seed used
    es_options.sampling_methods   - Procedures for sampling 
                                    'v from data'
                                    'v and mu'
                                    'c0 and c'
                                    'sample_and_discard'
                                    'convex_optimisation'  
    es_constraints.v_fix          - Predefined fluxes (vector, NaNs are ignored)
    es_constraints.v_min          - Lower flux bounds (vector, NaNs are ignored)
    es_constraints.v_max          - Upper flux bounds (vector, NaNs are ignored)
    es_constraints.v_sign         - Flux signs (vector, NaNs are ignored)
    es_constraints.log_u_mean     - Mean enzyme level (for sampling)
    es_constraints.log_u_std      - Std dev for enzyme levels (for sampling)
    es_constraints.log_c_mean     - Mean metabolite concentration (for sampling)
    es_constraints.log_c_std      - Std dev for metabolite concentrations (for sampling)
  
   Additionally required, depending on 'es_options.sampling_method':
     'v from data'          es_constraints.v_mean
                            es_constraints.v_std
   
     'v and mu'             es_constraints.mu_fix
   
     'c0 and c'             es_constraints.log_c0
                            es_constraints.log_c0_std
   
     'sample_and_discard'   es_options.cycle_correction

     'convex_optimisation'  es_constraints.dmu_fix
                            es_options.cycle_correction
  
   For some methods, additionally:
      es_options.ind_ignore  reactions to be ignored in thermodynamic loops 
                             (only needed for flux correction by loop substraction)
                             (only needed for flux correction by convex FBA)


 Outputs (with nm: # metabolites; nr: # reactions)
   c0        - Vector of chemical equilibrium concentrations (optional)
   c         - Vector of concentrations
   u         - Vector of enzyme levels
   J         - Flux vector
   Keq       - Vector of equilibrium constants
   mu        - Vector of chemical potentials
   K         - Kernel matrix 
   Kma       - Vector of mass-action ratios
   zeta      - zeta vector computed from reaction affinities
   A         - Vector of reaction affinities (thermodynamic driving forces)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="es_sample_model.html" class="code" title="function [result, es_options, es_constraints] = es_sample_model(N, W, ind_ext, es_constraints, es_options)">es_sample_model</a>	ES_SAMPLE_MODEL - Sample all model parameters for a network</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [c0, c, u, v, Keq, mu, K, Kma, zeta, A] = es_sample_steady_state_state(N, W, ind_ext, es_constraints, es_options)</a>
0002 
0003 <span class="comment">% ES_SAMPLE_STEADY_STATE - Sample feasible stationary state for a network</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% [c0, c, u, v, Keq, mu, K, Kma, zeta, A] = es_sample_steady_state_state(N, W, ind_ext, es_constraints, es_options)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Sample thermodynamically consistent steady states, including concentrations,</span>
0008 <span class="comment">% fluxes, and thermodynamic quantities. Enzyme levels are freely sampled.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Inputs (with nm: # metabolites; nr: # reactions)</span>
0012 <span class="comment">%   N         - Stoichiometric matrix (nm x nr)</span>
0013 <span class="comment">%   W         - Allosteric regulation matrix (nr x nm)</span>
0014 <span class="comment">%   ind_ext   - indices of external metabolites</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   For the inputs 'es_constraints' and 'es_options', see 'es_default_options'</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%  Fields in 'es_constraints' and 'es_options' relevant to this function:</span>
0019 <span class="comment">%    es_options.seed               - Random seed used</span>
0020 <span class="comment">%    es_options.sampling_methods   - Procedures for sampling</span>
0021 <span class="comment">%                                    'v from data'</span>
0022 <span class="comment">%                                    'v and mu'</span>
0023 <span class="comment">%                                    'c0 and c'</span>
0024 <span class="comment">%                                    'sample_and_discard'</span>
0025 <span class="comment">%                                    'convex_optimisation'</span>
0026 <span class="comment">%    es_constraints.v_fix          - Predefined fluxes (vector, NaNs are ignored)</span>
0027 <span class="comment">%    es_constraints.v_min          - Lower flux bounds (vector, NaNs are ignored)</span>
0028 <span class="comment">%    es_constraints.v_max          - Upper flux bounds (vector, NaNs are ignored)</span>
0029 <span class="comment">%    es_constraints.v_sign         - Flux signs (vector, NaNs are ignored)</span>
0030 <span class="comment">%    es_constraints.log_u_mean     - Mean enzyme level (for sampling)</span>
0031 <span class="comment">%    es_constraints.log_u_std      - Std dev for enzyme levels (for sampling)</span>
0032 <span class="comment">%    es_constraints.log_c_mean     - Mean metabolite concentration (for sampling)</span>
0033 <span class="comment">%    es_constraints.log_c_std      - Std dev for metabolite concentrations (for sampling)</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%   Additionally required, depending on 'es_options.sampling_method':</span>
0036 <span class="comment">%     'v from data'          es_constraints.v_mean</span>
0037 <span class="comment">%                            es_constraints.v_std</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%     'v and mu'             es_constraints.mu_fix</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%     'c0 and c'             es_constraints.log_c0</span>
0042 <span class="comment">%                            es_constraints.log_c0_std</span>
0043 <span class="comment">%</span>
0044 <span class="comment">%     'sample_and_discard'   es_options.cycle_correction</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%     'convex_optimisation'  es_constraints.dmu_fix</span>
0047 <span class="comment">%                            es_options.cycle_correction</span>
0048 <span class="comment">%</span>
0049 <span class="comment">%   For some methods, additionally:</span>
0050 <span class="comment">%      es_options.ind_ignore  reactions to be ignored in thermodynamic loops</span>
0051 <span class="comment">%                             (only needed for flux correction by loop substraction)</span>
0052 <span class="comment">%                             (only needed for flux correction by convex FBA)</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%</span>
0055 <span class="comment">% Outputs (with nm: # metabolites; nr: # reactions)</span>
0056 <span class="comment">%   c0        - Vector of chemical equilibrium concentrations (optional)</span>
0057 <span class="comment">%   c         - Vector of concentrations</span>
0058 <span class="comment">%   u         - Vector of enzyme levels</span>
0059 <span class="comment">%   J         - Flux vector</span>
0060 <span class="comment">%   Keq       - Vector of equilibrium constants</span>
0061 <span class="comment">%   mu        - Vector of chemical potentials</span>
0062 <span class="comment">%   K         - Kernel matrix</span>
0063 <span class="comment">%   Kma       - Vector of mass-action ratios</span>
0064 <span class="comment">%   zeta      - zeta vector computed from reaction affinities</span>
0065 <span class="comment">%   A         - Vector of reaction affinities (thermodynamic driving forces)</span>
0066 
0067 <span class="comment">% ---------------------------------------------------------------------------------</span>
0068 <span class="comment">% initialise</span>
0069 
0070 <span class="keyword">if</span> ~isnan(es_options.seed), 
0071   randn(<span class="string">'state'</span>,es_options.seed); 
0072   rand(<span class="string">'state'</span>,es_options.seed); 
0073 <span class="keyword">end</span>
0074 
0075 [nm,nr] = size(N);
0076 
0077 all_c_given   = sum(isnan(es_constraints.log_c_fix)) == 0;
0078 all_v_given   = sum(isnan(es_constraints.v_fix))     == 0;
0079 all_dmu_given = sum(isnan(es_constraints.dmu_fix))   == 0;
0080 all_mu_given  = sum(isnan(es_constraints.mu_fix))    == 0;
0081 all_keq_given = sum(isnan(es_constraints.Keq_fix))   == 0;
0082 
0083 
0084 <span class="comment">% ---------------------------------------------------------------------------------</span>
0085 <span class="comment">% determine fluxes</span>
0086 
0087 <span class="keyword">if</span> all_v_given,
0088   
0089   display(<span class="string">' Using given flux distribution'</span>);
0090 
0091   v = es_constraints.v_fix; 
0092 
0093 <span class="keyword">else</span>
0094 
0095   v = [];
0096   es_constraints.v_min(es_constraints.v_sign ==  1) = 0;
0097   es_constraints.v_max(es_constraints.v_sign == -1) = 0;
0098 
0099   <span class="keyword">switch</span> es_options.sampling_method,
0100     
0101     <span class="keyword">case</span> <span class="string">'accept_flux'</span>,
0102       v = es_constraints.v_mean;      
0103     
0104     <span class="keyword">case</span> <span class="string">'sample_and_discard'</span>,
0105       es_options.sampling_cycle_correction = 1;    
0106       [sample_v, best_v] = sample_fluxes_given_data(N, ind_ext, es_constraints.v_mean, es_constraints.v_std, 1, 1, 1, es_options.ind_ignore, es_constraints.v_sign);
0107       v = best_v.v;
0108     
0109     <span class="keyword">case</span> <span class="string">'convex_optimisation'</span>,
0110       es_options.sampling_cycle_correction = 1;
0111       [sample_v, best_v, res] = sample_fluxes_by_convex_fba(N,ind_ext,es_constraints.v_mean,es_constraints.v_std,struct,-es_constraints.dmu_fix);
0112       v                   = best_v.v;
0113       es_constraints.dmu_fix = -res.A;    <span class="comment">%</span>
0114     
0115     <span class="keyword">case</span> <span class="string">'v and mu'</span>,
0116       v = sample_feasible_v(N,ind_ext,es_constraints,es_options);  
0117     
0118     <span class="keyword">case</span> <span class="string">'v from data'</span>,
0119       sample_v = sample_fluxes_given_data(N, ind_ext, es_constraints.v_mean, es_constraints.v_std, 1, 1, 1, es_options.ind_ignore, es_constraints.v_sign);
0120       v        = sample_v.v{1};
0121       
0122     <span class="keyword">otherwise</span>,
0123     error(sprintf(<span class="string">'unknown method %s'</span>,  es_options.sampling_method));
0124   <span class="keyword">end</span>  
0125 
0126   <span class="keyword">if</span> length(v),
0127     <span class="keyword">if</span> es_options.sampling_cycle_correction,
0128       <span class="comment">%% correct        = es_check_flux_es_constraints(es_constraints.v_mean,N,ind_ext,es_constraints,1,epsilon_stationary,cycles);</span>
0129       <span class="comment">%% correct mean fluxes by Nathan's method (requires variable 'ind_ignore')</span>
0130       [v_feas, C] = eba_make_feasible(v, N, <span class="string">'loose'</span>, nan, es_options.ind_ignore, <span class="string">'efmtool'</span>);
0131       v = v_feas;  <span class="comment">% if not given -&gt; fluxes are sampled again</span>
0132     <span class="keyword">end</span>
0133   <span class="keyword">end</span>
0134 
0135 <span class="keyword">end</span>
0136 
0137 <span class="comment">% ---------------------------------------------------------------------------------</span>
0138 <span class="comment">% now do the rest</span>
0139 
0140 <span class="comment">%% sample c freely, determine Keq, A, zeta, depending on given information</span>
0141 
0142 c0       = [];
0143 mu       = [];
0144 K        = [];
0145 c        = exp(es_constraints.log_c_mean + es_constraints.log_c_std .* randn(nm,1));
0146 ind_c    = find(isfinite(es_constraints.log_c_fix));
0147 c(ind_c) = exp(es_constraints.log_c_fix(ind_c));
0148 Kma      = exp(N' * log(c));
0149 
0150 <span class="keyword">if</span> all_mu_given,
0151   display(<span class="string">' Using given chemical potentials'</span>);
0152   mu   = es_constraints.mu_fix;
0153   A    = - N' * mu;
0154   zeta = exp(es_options.h .* A/RT);
0155   Keq  = exp(A/RT) .* Kma;
0156 
0157 <span class="keyword">elseif</span> all_dmu_given,
0158   display(<span class="string">' Using given chemical potential differences'</span>);
0159   A    = - es_constraints.dmu_fix;
0160   zeta = exp(es_options.h .* A/RT);
0161   Keq  = exp(A/RT) .* Kma;
0162   mu   = -pinv(full(N'))*A;
0163   display(<span class="string">' * Computing mu from A by pseudoinverse (in es_sample_steady_state)'</span>);
0164 
0165 <span class="keyword">elseif</span> all_keq_given,
0166   display(<span class="string">' Using given equilibrium constants'</span>);
0167   Keq  = es_constraints.Keq_fix;
0168   A    = RT * log(Keq ./ Kma);
0169   zeta = exp(es_options.h .* A/RT);
0170 
0171 <span class="keyword">else</span>,
0172   <span class="comment">%% sample mu</span>
0173   <span class="keyword">if</span> es_options.verbose, display(<span class="string">' Computing extreme feasible mu vectors ..'</span>); <span class="keyword">end</span>
0174   [mu_list, feasible] = sample_feasible_mu(N, ind_ext, v, es_constraints, es_options);
0175   <span class="keyword">if</span> es_options.verbose, display(<span class="string">' .. done'</span>); <span class="keyword">end</span>
0176   <span class="keyword">if</span> ~feasible, error(<span class="string">'Unfeasible flux distribution'</span>); <span class="keyword">end</span>
0177   display(<span class="string">'  Choosing chemical potentials mu randomly from extreme points of the allowed region'</span>);
0178   mu     = mu_list(:,ceil(rand*size(mu_list,2)));
0179   log_c  = log(c);
0180   log_c0 = log_c - mu/RT;
0181   Keq    = exp(N'*log_c0);
0182   Kma    = exp(N' * log(c));
0183   zeta   = [Keq./Kma].^es_options.h;
0184   A      = RT * log(Keq./Kma);
0185 <span class="keyword">end</span>
0186 
0187 <span class="keyword">if</span> find([v~=0].*[abs(A) &lt; es_constraints.dmu_limit_min]), error(<span class="string">'Overly small reaction affinity encountered'</span>); <span class="keyword">end</span>
0188 <span class="keyword">if</span> find([v~=0].*[abs(A) &gt; [1+10^-5]*es_constraints.dmu_limit]),     error(<span class="string">'Overly large reaction affinity encountered'</span>); <span class="keyword">end</span>
0189 
0190 <span class="comment">% ----------------------------------------------------------------------</span>
0191 <span class="comment">% output quantities</span>
0192 
0193 u    = exp(es_constraints.log_u_mean + es_constraints.log_u_std .* randn(nr,1));
0194 
0195 <span class="keyword">if</span> sum(v .* A&lt;0), 
0196   [v,A, sign(v)~=sign(A)]
0197   error(<span class="string">'Signs of reaction rates and affinities disagree!!!'</span>); <span class="keyword">end</span> 
0198 
0199 
0200 <span class="comment">% switch es_options.sampling_method,</span>
0201 <span class="comment">%</span>
0202 <span class="comment">%   case 'c0 and c';</span>
0203 <span class="comment">%</span>
0204 <span class="comment">%       ok       = 0;</span>
0205 <span class="comment">%       it       = 0;</span>
0206 <span class="comment">%       n_trials = 100000;</span>
0207 <span class="comment">%       K        = sparse(null(N_int,'r'));</span>
0208 <span class="comment">%</span>
0209 <span class="comment">%       while (ok == 0) &amp;  (it &lt; n_trials),</span>
0210 <span class="comment">%</span>
0211 <span class="comment">%         it = it+1;</span>
0212 <span class="comment">%</span>
0213 <span class="comment">%         %% sample c0 and c</span>
0214 <span class="comment">%         log_c0   = es_constraints.log_c0_mean + es_constraints.log_c0_std .* randn(nm,1);</span>
0215 <span class="comment">%         log_c    = es_constraints.log_c_mean  + es_constraints.log_c_std  .* randn(nm,1);</span>
0216 <span class="comment">%</span>
0217 <span class="comment">%         %% compute Keq, mu, A</span>
0218 <span class="comment">%         log_Keq  = N'*log_c0;</span>
0219 <span class="comment">%         mu       = RT * ( log_c - log_c0 );</span>
0220 <span class="comment">%         A        = - N' * mu;</span>
0221 <span class="comment">%</span>
0222 <span class="comment">%         %% sample fluxes v given the directions set by A</span>
0223 <span class="comment">%         ind_prescribed_signs = find(isfinite(es_constraints.vsigns));</span>
0224 <span class="comment">%         n_prescribed_signs   = length(ind_prescribed_signs);</span>
0225 <span class="comment">%         dummy                = diag(es_constraints.vsigns);</span>
0226 <span class="comment">%         ind_ext_signs = find(isfinite(es_constraints.ext_signs));</span>
0227 <span class="comment">%</span>
0228 <span class="comment">%         M = [diag(sign(A)); ...</span>
0229 <span class="comment">%              eye(nr); ...</span>
0230 <span class="comment">%              - eye(nr); ...</span>
0231 <span class="comment">%              dummy(ind_prescribed_signs,:); ...</span>
0232 <span class="comment">%              diag(es_constraints.ext_signs(ind_ext_signs)) * N(ind_ext_signs,:) ] * K;</span>
0233 <span class="comment">%</span>
0234 <span class="comment">%         b = [zeros(nr,1); ...</span>
0235 <span class="comment">%              es_constraints.vmin; ...</span>
0236 <span class="comment">%              -es_constraints.vmax; ...</span>
0237 <span class="comment">%              zeros(n_prescribed_signs,1);...</span>
0238 <span class="comment">%              zeros(length(ind_ext_signs),1) ];</span>
0239 <span class="comment">%</span>
0240 <span class="comment">%         if isfield(es_constraints,'v'),   v_red = pinv(full(K)) * es_constraints.v;</span>
0241 <span class="comment">%         else,                          v_red = randn(size(K,2),1);</span>
0242 <span class="comment">%         end</span>
0243 <span class="comment">%</span>
0244 <span class="comment">%         if sum(M*v_red &lt; b) == 0,  ok = 1; end</span>
0245 <span class="comment">%</span>
0246 <span class="comment">%       end</span>
0247 <span class="comment">%</span>
0248 <span class="comment">%       v = K * v_red;</span>
0249 <span class="comment">%</span>
0250 <span class="comment">%       if ok == 0,</span>
0251 <span class="comment">%         display('Warning, no feasible combination found');</span>
0252 <span class="comment">%         log_c0  = nan * log_c0;</span>
0253 <span class="comment">%         log_c   = nan * log_c;</span>
0254 <span class="comment">%         log_Keq = nan * log_Keq;</span>
0255 <span class="comment">%         v       = nan * v;</span>
0256 <span class="comment">%       end</span>
0257 <span class="comment">%</span>
0258 <span class="comment">%       c0   = exp(log_c0 );</span>
0259 <span class="comment">%       c    = exp(log_c  );</span>
0260 <span class="comment">%       Keq  = exp(log_Keq);</span>
0261 <span class="comment">%</span>
0262 <span class="comment">%   end</span>
0263 <span class="comment">%</span>
0264 <span class="comment">%   Kma  = exp(N' * log(c));</span>
0265 <span class="comment">%   zeta = [Keq./Kma].^es_options.h;</span>
0266 <span class="comment">%   A    = RT * log(Keq./Kma);</span>
0267 <span class="comment">%</span>
0268 <span class="comment">% end</span></pre></div>
<hr><address>Generated on Wed 10-Apr-2013 10:44:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>